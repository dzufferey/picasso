// Michael scott queue

init
  node (s, SPAWN)
  node (q, queue)

transition "spawn enq"
pre
  node (s, SPAWN)
  node (q, queue)
post
  node (s, SPAWN)
  (q, queue) -> (e, enq0) [enq]
  (e, enq0) -> (x, x) [x]
==>
  q -> q
  s -> s
<==


transition "spawn deq"
pre
  node (s, SPAWN)
  node (q, queue)
post
  node (s, SPAWN)
  (q, queue) -> (d, deq0) [deq]
  (d, deq0) -> (x, x) [x]
==>
  q -> q
  s -> s
<==

// ****************************************************************
// STOP SPAWN

transition "nwaps"
pre
  node (s, SPAWN)
post
  node (s, NWAPS)
==>
  s -> s
<==

// ****************************************************************
// READ

transition "enq read"
pre
  node (n, NWAPS)
  (q, queue) -> (w, _) [T]
  (q, queue) -> (e, enq0) [enq]
  (e, enq0) -> (x, x) [x]
post
  node (n, NWAPS)
  (q, queue) -> (w, _) [T]
  (q, queue) -> (e, enq1) [enq]
  (e, enq1) -> (w, _) [T] 
  (e, enq1) -> (x, x) [x]
==>
  n -> n
  q -> q
  e -> e
  x -> x
<==
  w -> w

// ****************************************************************
// enq succeeds

transition "enq ok"
pre
  node (n, NWAPS)
  (q, queue) -> (m, emp) [T]
  (q, queue) -> (m, emp) [H]
  (q, queue) -> (e, enq1) [enq]
  (e, enq1) -> (m, emp) [T]
  (e, enq1) -> (x, x) [x]
post
  node (n, NWAPS)
  (q, queue) -> (m, emp) [A]
  (q, queue) -> (x, x) [H]
  (q, queue) -> (x, x) [T]
  (q, queue) -> (e, enq1) [enq]
  (e, enq1) -> (x, x) [T]
==>
  n -> n
  q -> q
  e -> e
  m -> m
  x -> x
<==


transition "enq ok, but H!=T"
pre
  node (n, NWAPS)
  (q, queue) -> (m, emp) [T]
  (q, queue) -> (w, _) [H]
  (q, queue) -> (e, enq1) [enq]
  (e, enq1) -> (m, emp) [T]
  (e, enq1) -> (x, x) [x]
post
  node (n, NWAPS)
  (q, queue) -> (m, emp) [A]
  (q, queue) -> (w, _) [H]
  (q, queue) -> (x, x) [T]
  (q, queue) -> (e, enq1) [enq]
  (e, enq1) -> (x, x) [T]
==>
  n -> n
  q -> q
  e -> e
  m -> m
  x -> x
<==
  w -> w


// ****************************************************************
transition "swing/true"
pre
  node (n, NWAPS)
  (q, queue) -> (m, emp) [A]
  (q, queue) -> (w, _) [T]
  (q, queue) -> (e, enq1) [enq]
  (e, enq1) -> (w, _) [T]
post
  node (n, NWAPS)
  (q, queue) -> (m, emp) [T]
  (q, queue) -> (w, _) [M]
  (q, queue) -> (e, enq0) [enq]
==>
  n -> n
  q -> q
  e -> e
  m -> m
<==
  w -> w

// ****************************************************************
transition "swing/false"
pre
  node (n, NWAPS)
  (q, queue) -> (w, _) [T]
  (q, queue) -> (e, enq1) [enq]
  (e, enq1) -> (w2, _) [T]
post
  node (n, NWAPS)
  node (w2, _)
  (q, queue) -> (w, _) [T]
  (q, queue) -> (e, enq1) [enq]
==>
  n -> n
  q -> q
  e -> e
<==
  w -> w
  w2 -> w2


// ****************************************************************
transition "eqn term"
pre
  node (n, NWAPS)
  node (e, enq0)
post
  node (n, NWAPS)
  node (e, enq0done)
==>
  n -> n
  e -> e
<==
no
  (e, enq0) -> (x, x) [x]



// ****************************************************************
// DEQ READ 

transition "deq step1: read H"
pre
  node (n, NWAPS)
  (q, queue) -> (d, deq0) [deq]
  (q, queue) -> (w, _) [H]
post
  node (n, NWAPS)
  (q, queue) -> (d, deq1) [deq]
  (q, queue) -> (w, _) [H]
  (d, deq1) -> (w, _) [H]
==>
  n -> n
  q -> q
  d -> d
<==
  w -> w


// ****************************************************************
// DEQ READ 2

transition "deq step2: read T SHLD HAVE ANOTHER CASE"
pre
  node (n, NWAPS)
  (q, queue) -> (d, deq1) [deq]
  (q, queue) -> (w, _) [T]
  (d, deq1) -> (w, _) [H]
post
  node (n, NWAPS)
  (q, queue) -> (d, deq2) [deq]
  (q, queue) -> (w, _) [T]
  (d, deq2) -> (w, _) [H]
  (d, deq2) -> (w, _) [T]
==>
  n -> n
  q -> q
  d -> d
<==
  w -> w


// ****************************************************************
// DEQ OK

transition "deq succeed"
pre
  node (n, NWAPS)
  (q, queue) -> (d, deq2) [deq]
  (q, queue) -> (w1, _) [H]
  (q, queue) -> (w2, _) [M]
  (q, queue) -> (w3, _) [T]
  (d, deq2) -> (w1, _) [H]
  (d, deq2) -> (w3, _) [T]
post
  node (n, NWAPS)
  node (d, deq2done)
  node (w1, _)
  (q, queue) -> (w2, _) [H]
  (q, queue) -> (w3, _) [T]
==>
  n -> n
  q -> q
  d -> d
<==
  w1 -> w1
  w2 -> w2
  w3 -> w3

transition "deq succeed, no middle"
pre
  node (n, NWAPS)
  (q, queue) -> (d, deq2) [deq]
  (q, queue) -> (w1, _) [H]
  (q, queue) -> (w2, _) [T]
  (d, deq2) -> (w1, _) [H]
  (d, deq2) -> (w2, _) [T]
post
  node (n, NWAPS)
  node (d, deq2done)
  node (w1, _)
  (q, queue) -> (w2, _) [H]
  (q, queue) -> (w2, _) [T]
==>
  n -> n
  q -> q
  d -> d
<==
  w1 -> w1
  w2 -> w2
//  w3 -> w3

// ****************************************************************
// Dequeuer swings tail pointer

transition "deq swing/true"
pre
  node (n, NWAPS)
  (q, queue) -> (d, deq2) [deq]
  (q, queue) -> (w2, _) [A]
  (q, queue) -> (w1, _) [T]
  (d, deq2) -> (w1, _) [H]
  (d, deq2) -> (w1, _) [T]
post
  node (n, NWAPS)
  (q, queue) -> (d, deq0) [deq]
  (q, queue) -> (w1, _) [M]
  (q, queue) -> (w2, _) [T]
==>
  n -> n
  q -> q
  d -> d
<==
  w1 -> w1
  w2 -> w2

transition "deq swing/false"
pre
  node (n, NWAPS)
  (q, queue) -> (d, deq2) [deq]
  (q, queue) -> (w1, _) [T]
  (d, deq2) -> (w2, _) [H]
  (d, deq2) -> (w2, _) [T]
post
  node (n, NWAPS)
  node (w2, _)
  (q, queue) -> (d, deq0) [deq]
  (q, queue) -> (w1, _) [T]
==>
  n -> n
  q -> q
  d -> d
<==
  w1 -> w1
  w2 -> w2

// ****************************************************************

